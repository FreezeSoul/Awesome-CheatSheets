[![返回目录](https://parg.co/UCb)](https://github.com/wxyyxc1992/Awesome-CheatSheet)

# Docker Internals CheatSheet | Docker 内部原理简析与实现

LXC
一种操作系统级虚拟化方法，在执行时不用重复加载内核, 且其内核与宿主共享，允许其他一些沙盒进程运行在一块相对独立的空间，并且能够方便的控制他们的资源调度。

namespace
通过 namespace 实现容器间的隔离性。容器内的应用只能在自己的命名空间中运行而且不会访问到命名空间之外。

cgroups（Control Groups)
用来管理群组。使应用隔离运行的关键是让它们只使用你想要的资源。这样可以确保在机器上运行的容器都是良民(good multi-tenant citizens)。群组控制允许 Docker 分享或者限制容器使用硬件资源。

AUFS (AnotherUnionFS)
一种 Union FS, 支持将不同目录挂载到同一个虚拟文件系统下的文件系统。

容器运行时的只读模板。每一个镜像由一系列的层 (layers) 组成，层是由 Dockerfile 指定。copy on write
写时复制。容器是由镜像所创建，会根据多层文件系统构建一个镜像栈，只有栈的最顶层是读写层。如果发生对只读层的写操作时会将该文件复制到读写层，并隐藏只读层的文件。

联合文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into asingle virtual filesystem)。
联合文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。
另外，不同 Docker 容器就可以共享一些基础的文件系统层，同时再加上自己独有的改动层，大大提高了存储的效率。
Docker 中使用的 AUFS（AnotherUnionFS）就是一种联合文件系统。 AUFS 支持为每一个成员目录（类似 Git 的分支）设定只读（readonly）、读写（readwrite）和写出（whiteout-able）权限, 同时 AUFS 里有一个类似分层的概念, 对只读权限的分支可以逻辑上进行增量地修改(不影响只读部分的)。
Docker 目前支持的联合文件系统种类包括 AUFS, btrfs, vfs 和 DeviceMapper

要想实现网络通信，机器至少需要一个网络接口(物理接口或虚拟接口)与外界相通，并可以收发数据包；另外，如果不同子网之间要进行通信，则需要额外的路由机制。Docker 的网络接口默认都是虚拟接口。虚拟接口的最大优势就是转发效率极高！之所以会这样，那是因为 Linux 通过在内核中进行数据复制来实现虚拟接口间的数据转发，即直接复制发送接口的发送缓存中的数据包到接收接口的接收缓存中，而无需通过外部物理网络设备进行交换。对于本地系统和容器内系统来看，虚拟接口和一个正常的以太网卡相比并无区别，只是虚拟接口的速度要快得多。

2.5.2 网络创建过程
创建一对虚拟接口，分别放到宿主机和容器的命名空间中；
宿主机一端的虚拟接口连接到默认的 docker0 网桥或指定网桥上，并具有一个以 veth 开头的唯一的名字;
容器一端的虚拟接口将被放到容器中，并修改名称为 eth0，且这个接口只对该容器的命名空间可见；4. 从网桥可用地址段中获取一个空闲的地址分配给容器的 eth0(如 172.17.0.2/16)，并配置默认路由网关为 docker0 网卡的内部接口 docker0 的 IP 地址(如 172.17.42.1/16)；
完成以上这些，容器就可以使用自身可见的 eth0 虚拟网卡来连接其他容器和访问外部网络。另外，可以在容器创建启动时通过--net 参数来指定容器的网络配置

# Cgroup

Docker 允许使用 cpus, cpuset-cpus, cpu-shares 等来限制容器的计算资源占用：

```sh
# 最多允许占用单 CPU 50% 的计算资源，如果双核 CPU，则可以设置为 1.5 等
$ docker run -it --cpus=".5" ubuntu /bin/bash

# 指定容器可占用的 CPU 核编号，0-3 表示占用四个核，1,3 表示占用两个核
$ docker run -it --cpuset-cpus="1,3" ubuntu /bin/bash

# 不同的值能够指定不同的容器权重，用于动态分配 CPU 资源
$ docker run -it --cpu-shares="512" ubuntu /bin/bash
```

CPU set 方式的优点是：各容器的 CPU 核是确定的，具备较强的安全性。整体资源利用率低。容器声明了使用多个 CPU，一方面，该容器实际并不需要如此多核的 CPU 资源来处理任务；另一方面，其他容器上的任务无法利用该容器上的 CPU 空闲时间片。人为上阻断了 CPU 闲时复用的能力。

CPU share 是一种 CPU 资源分配的方式，广义上可以理解为：通过共享的方式获得 CPU 资源。对于在线业务，我们是以容器为单位获取资源，share 就是不同的容器共享一定总量的 CPU 计算能力，每个容器都绑定全量核，而每个容器获取一定份额的 CPU 计算力；狭义的理解，专门指内核 CFS(completely fair scheduler)调度器针对各 Cgroup（叶子 cgroup 就是一个容器）的 CPU 资源配置方式。
CPU share 模式下，每个容器的 CPU 资源分配不再以整核分配，而是可精细到 CPU 时间片份额的粒度，并且是连续的 CPU 核能力值，比如：某物理机 M1（有 64 个逻辑 CPU 核），上面只分配了一个 CPU share 为 3.5 核当量（等于 3.5 个核的 CPU 处理力）的 A 容器，其可以理解为：A 容器在需要时最少可以拿到 3.5 份 CPU 计算力，如果整机上 CPU 有空闲，而 A 容器也需要比 3.5 核 CPU 更多，则 A 可以在 share 机制下获得更多 CPU 计算力。这也就是 share 带了的共享收益，当整机闲时，可以让较为繁忙的业务获得整机空闲。采用 CPU 资源共享的机制，其资源隔离性没有 set 模式强，对于极个别 CPU 资源敏感型业务，有可能出现偶尔等待 CPU 时间片的情况，而影响业务稳定性。对于极少数的这类业务，我们容许继续使用 CPU set 模式。
可能因某个异常容器占用或不合理使用整机 CPU 资源，造成宿主机上大量容器异常，单容器的 CPU 资源约束及上限将变得非常重要，既不能限得太死，又不能限不住，将通过内核和调度系统的限制机制来保障资源稳定性。
