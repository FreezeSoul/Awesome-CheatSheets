
# 分库分表

## 全局 ID

原本一个数据库上的自增id的结果，在分库分表下并不是全局唯一的. 所以，分库分表后需要有一种技术可以生成全局的唯一id。生成全局唯一的id;
保持高性能;
保持高可用
目前常见的几种全局ID的思路：

- oracle sequence : 基于第三方oracle的SEQ.NEXTVAL来获取一个ID 优势：简单可用 缺点：需要依赖第三方oracle数据库

- mysql id区间隔离 : 不同分库设置不同的起始值和步长，比如2台mysql，就可以设置一台只生成奇数，另一台生成偶数. 或者1台用0~10亿，另一台用10~20亿. 优势：利用mysql自增id 缺点：运维成本比较高，数据扩容时需要重新设置步长.

- 基于数据库更新＋内存分配： 在数据库中维护一个ID，获取下一个ID时，会对数据库进行ID=ID+100 WHERE ID=XX，拿到100个ID后，在内存中进行分配 优势：简单高效 缺点：无法保证自增顺序

# 单元化

单元化就是一批机器的集合，现在要改造，其实是将以前单个单元（也就是我们所谓的中心机房）扩展成多个机器单元，也就是经常听到的异地多活。单元化要做的事情就是让业务上下游的系统调用变成单元内封闭的调用，减少跨单元调用的网络损耗，同时又方便扩容和容灾。非买家相关的服务这些由于涉及到的数据都是共享型的，如果每个单元都有写入，则很难保证每个单元读取的数据一致性，比如库存。那么非买家相关的单元化方案就是将这些数据的写入统一路由到一个名为center的单元,然后将数据同步到每个非center的单元.这样每个单元都会有一份全量,非center单元的读操作都可以在单元内完成；而买家相关的服务则是中心跟单元都可以读写。
