# 分库分表

## 全局 ID

原本一个数据库上的自增 id 的结果，在分库分表下并不是全局唯一的. 所以，分库分表后需要有一种技术可以生成全局的唯一 id。生成全局唯一的 id;
保持高性能;
保持高可用
目前常见的几种全局 ID 的思路：

- oracle sequence : 基于第三方 oracle 的 SEQ.NEXTVAL 来获取一个 ID 优势：简单可用 缺点：需要依赖第三方 oracle 数据库

- mysql id 区间隔离 : 不同分库设置不同的起始值和步长，比如 2 台 mysql，就可以设置一台只生成奇数，另一台生成偶数. 或者 1 台用 0~10 亿，另一台用 10~20 亿. 优势：利用 mysql 自增 id 缺点：运维成本比较高，数据扩容时需要重新设置步长.

- 基于数据库更新＋内存分配：在数据库中维护一个 ID，获取下一个 ID 时，会对数据库进行 ID=ID+100 WHERE ID=XX，拿到 100 个 ID 后，在内存中进行分配 优势：简单高效 缺点：无法保证自增顺序

# 单元化

单元化就是一批机器的集合，现在要改造，其实是将以前单个单元（也就是我们所谓的中心机房）扩展成多个机器单元，也就是经常听到的异地多活。单元化要做的事情就是让业务上下游的系统调用变成单元内封闭的调用，减少跨单元调用的网络损耗，同时又方便扩容和容灾。非买家相关的服务这些由于涉及到的数据都是共享型的，如果每个单元都有写入，则很难保证每个单元读取的数据一致性，比如库存。那么非买家相关的单元化方案就是将这些数据的写入统一路由到一个名为 center 的单元,然后将数据同步到每个非 center 的单元.这样每个单元都会有一份全量,非 center 单元的读操作都可以在单元内完成；而买家相关的服务则是中心跟单元都可以读写。
