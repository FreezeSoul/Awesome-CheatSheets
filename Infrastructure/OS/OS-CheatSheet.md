[![返回目录](https://parg.co/UCb)](https://github.com/wxyyxc1992/Awesome-CheatSheet)

# OS CheatSheet | 操作系统必知必会

# 调度算法

## 批处理作业调度

1.先来先服务调度算法（FCFS）:就是按照各个作业进入系统的自然次序来调度作业。这种调度算法的优点是实现简单，公平。其缺点是没有考虑到系统中各种资源的综合使用情况，往往使短作业的用户不满意，因为短作业等待处理的时间可能比实际运行时间长得多。

2.短作业优先调度算法(SPF): 就是优先调度并处理短作业，所谓短是指作业的运行时间短。而在作业未投入运行时，并不能知道它实际的运行时间的长短，因此需要用户在提交作业时同时提交作业运行时间的估计值。

3.最高响应比优先算法(HRN)：FCFS 可能造成短作业用户不满，SPF 可能使得长作业用户不满，于是提出 HRN，选择响应比最高的作业运行。响应比=1+作业等待时间/作业处理时间。

4. 基于优先数调度算法(HPF)：每一个作业规定一个表示该作业优先级别的整数，当需要将新的作业由输入井调入内存处理时，优先选择优先数最高的作业。

5.均衡调度算法，即多级队列调度算法

基本概念：

作业周转时间（Ti）＝完成时间(Tei)－提交时间(Tsi)

作业平均周转时间(T)＝周转时间/作业个数

作业带权周转时间（Wi）＝周转时间/运行时间

响应比＝（等待时间＋运行时间）/运行时间

## 进程调度

1.先进先出算法(FIFO)：按照进程进入就绪队列的先后次序来选择。即每当进入进程调度，总是把就绪队列的队首进程投入运行。

2. 时间片轮转算法(RR)：分时系统的一种调度算法。轮转的基本思想是，将 CPU 的处理时间划分成一个个的时间片，就绪队列中的进程轮流运行一个时间片。当时间片结束时，就强迫进程让出 CPU，该进程进入就绪队列，等待下一次调度，同时，进程调度又去选择就绪队列中的一个进程，分配给它一个时间片，以投入运行。

3. 最高优先级算法(HPF)：进程调度每次将处理机分配给具有最高优先级的就绪进程。最高优先级算法可与不同的 CPU 方式结合形成可抢占式最高优先级算法和不可抢占式最高优先级算法。

4. 多级队列反馈法：几种调度算法的结合形式多级队列方式。

## 空闲分区分配算法

1. 首先适应算法：当接到内存申请时，查找分区说明表，找到第一个满足申请长度的空闲区，将其分割并分配。此算法简单，可以快速做出分配决定。

2. 最佳适应算法：当接到内存申请时，查找分区说明表，找到第一个能满足申请长度的最小空闲区，将其进行分割并分配。此算法最节约空间，因为它尽量不分割到大的空闲区，其缺点是可能会形成很多很小的空闲分区，称为“碎片”。

3. 最坏适应算法：当接到内存申请时，查找分区说明表，找到能满足申请要求的最大的空闲区。该算法的优点是避免形成碎片，而缺点是分割了大的空闲区后，在遇到较大的程序申请内存时，无法满足的可能性较大。

## 虚拟页式存储管理中的页面置换算法

1.理想页面置换算法(OPT)：这是一种理想的算法，在实际中不可能实现。该算法的思想是：发生缺页时，选择以后永不使用或在最长时间内不再被访问的内存页面予以淘汰。

2.先进先出页面置换算法(FIFO)：选择最先进入内存的页面予以淘汰。

3. 最近最久未使用算法（LRU）：选择在最近一段时间内最久没有使用过的页，把它淘汰。

4.最少使用算法（LFU）：选择到当前时间为止被访问次数最少的页转换。

## 磁盘调度

1.先来先服务（FCFS）：是按请求访问者的先后次序启动磁盘驱动器，而不考虑它们要访问的物理位置

2.最短寻道时间优先（SSTF）：让离当前磁道最近的请求访问者启动磁盘驱动器，即是让查找时间最短的那个作业先执行，而不考虑请求访问者到来的先后次序，这样就克服了先来先服务调度算法中磁臂移动过大的问题

3.扫描算法（SCAN）或电梯调度算法：总是从磁臂当前位置开始，沿磁臂的移动方向去选择离当前磁臂最近的那个柱面的访问者。如果沿磁臂的方向无请求访问时，就改变磁臂的移动方向。在这种调度方法下磁臂的移动类似于电梯的调度，所以它也称为电梯调度算法。

4.循环扫描算法（CSCAN）：循环扫描调度算法是在扫描算法的基础上改进的。磁臂改为单项移动，由外向里。当前位置开始沿磁臂的移动方向去选择离当前磁臂最近的哪个柱面的访问者。如果沿磁臂的方向无请求访问时，再回到最外，访问柱面号最小的作业请求。

# I/O

不同应用通常具有不同的 I/O 类型，了解应用的 I/O 类型是为其设计解决方案、排错性能问题的首要工作。那 I/O 类型通常包括哪些需要考虑的因素？我们今天就来谈一谈 I/O 类型的几个重要方面。

读 vs. 写

     应用程序的读写请求必须量化，了解他们之间的比列，因为读写对存储系统的资源消耗是不通的。了解读写比率直接关系到如何应用缓存、RAID类型等子系统的最佳实践。写通常需要比读更多的资源，SSD的写操作相对读更是慢得多。

顺序 vs. 随机

     传统存储系统通常都是机械硬盘，因此整个系统设计为尽可能顺序化I/O，减少由于磁盘寻道所带来的延迟。所以，顺序I/O相对随机I/O的性能会好很多。随机小I/O消耗比顺序大I/O更多的处理资源。随机小I/O更在意系统处理I/O的数量，即IOPS；而顺序大I/O则更在意带宽，即MB/s。因此，如果系统承载了多种不同的应用，必须了解它们各自的需求，是对IOPS有要求，还是对带宽有要求。这往往需要在两种之间进行折衷考虑。闪盘是一个例外，它没有机械寻道操作，因此对随机小I/O的处理是非常迅速的，由此是读操作。

大 I/O vs. 小 I/O

     我们通常把<=16KB的I/O认为是小I/O，而>=32KB的I/O认为是大I/O。就单个I/O来讲，大I/O从微观的角度相比小I/O会需要更多处理资源，不过对于智能存储系统来说，会尽可能把I/O整理为顺序的，以单个操作执行，如此依赖，将多个小I/O整理成单个大I/O处理后，反而会更快。I/O的大小依然取决于应用程序本身，了解I/O的大小，影响到后期对缓存、RAID类型、LUN的一些属性的调优。

位置引用

     数据的位置分布影响到后期对二级缓存或存储分层技术的应用，因为这些技术都会根据I/O的位置分布来判断是否将I/O放置到缓存或快速的层级。位置引用是指那些被频繁的存储位置，我们通常认为最新创建的数据以及最近被访问过的数据，它们周围的数据也同时被访问的可能性会比较大。因此，了解应用程序的I/O位置特性，有助于应用正确的性能优化技术。

稳定 vs. 爆发

     I/O数量在一天中的不同时段会有不同的表现。例如，早高峰时段的I/O数量相比下班后的I/O会多出许多。如果能准确预测和估计应用的I/O在不同时间段的稳定性和爆发性，可以正确分配资源，提高资源利用率。在前期的设计阶段，就应该考虑系统是否能够处理I/O高峰期。

多线程 vs. 单线程

     多线程是实现并发操作的一种方式，同时也意味着对存储系统的资源消耗更多。这种高IOPS的请求方式，在有些情况下会造成磁盘繁忙，进而导致I/O排队，增加了响应时间。因此，适度的调整线程数量，不仅可以实现并发，而且能在不拖累整个存储系统的情况下，达到最优的响应时间。
