[![返回目录](https://i.postimg.cc/JzFTMvjF/image.png)](https://github.com/wx-chevalier/Awesome-CheatSheets)

# Regex CheatSheet | 正则表达式清单

![](https://github.com/zeeshanu/learn-regex/raw/master/img/regexp-en.png)

- Symbols

  - `.` —  匹配除了换行之外的任意字符
  - `^` —  匹配字符串的首部
  - `$` —  匹配字符串的末尾

- Number

  - `*` —  匹配前述的表达式零或多次
  - `+` —  匹配前述的表达式一或多次
  - `?` —  匹配前述的表达式零或一次
  - `a{3}` - 匹配指定数目的 a
  - `a{3,}` - 匹配不少于 3 个的 a
  - `a{3,6}` - 匹配 3 到 6 个 a

- Character groups

  - `\d` —  匹配任意的数值
  - `\w` —  匹配任意的字符
  - `[XYZ]` —  数组中任一值匹配，多范围混搭的话，可以使用 `[A-Z][xyz]+` 来匹配集合中的任一字符
  - `[^a-z]` — `^` 用于进行反选，这里即表示匹配非 a-z 字符的其他值；`([^B]*)` 表示该位置是除了 B 之外的任意值。

- Advanced

  - `(x)` —  捕获圆括号，匹配 x 并且记录捕获项
  - `(x|y)` - 匹配 x 或者 y
  - `(?:x)` —  非匹配圆括号，仅匹配而不记录
  - `x(?=y)` —  预测匹配，仅匹配那些 y 之前的 x

- Flags

  - `g` —  全局搜索
  - `i` —  大小写敏感搜索

# 结构与操作符

## 元字符

元字符是构造正则表达式的一种基本元素。

元字符	说明
.	匹配除换行符以外的任意字符
\w	匹配字母或数字或下划线或汉字
\s	匹配任意的空白符
\d	匹配数字
\b	匹配单词的开始或结束
^	匹配字符串的开始
$	匹配字符串结束

正则提供了转义的方式，也就是要把这些元字符、限定符或者关键字转义成普通的字符，做法很简答，就是在要转义的字符前面加个斜杠，也就是\即可。



## 重复限定符

正则表达式中一些重复限定符，把重复部分用合适的限定符替代，下面我们来看一些限定符：

语法	说明
*	重复零次或更多次
+	重复一次或更多次
?	重复零次或一次
{n}	重复n次
{n,}	重复n次或更多次
{n,m}	重复n到m次

## 分组与条件

正则表达式中用小括号 () 来做分组，也就是括号中的内容作为一个整体。

正则用符号 | 来表示或，也叫做分支条件，当满足正则里的分支条件的任何一种条件时，都会当成是匹配成功。

 ^(130|131|132|155|156|185|186|145|176)\d{8}$


# 数量与匹配模式

在正则表达式中有这么三种模式：贪婪模式、懒惰模式、独占模式。在关于数量的匹配中，有 `+ ? * {min,max}` 四种两次，如果只是单独使用，那么它们就是贪婪模式。

## 贪婪模式

## 懒惰模式

如果在他们之后加多一个 ? 符号，那么原先的贪婪模式就会变成懒惰模式，即尽可能少地匹配。但是懒惰模式还是会发生回溯现象的。TODO 例如下面这个例子：

```js
text = 'abbc';

regex = 'ab{1,3}?c';
```

正则表达式的第一个操作符 a 与 字符串第一个字符 a 匹配，匹配成。于是正则表达式的第二个操作符 b{1,3}? 和 字符串第二个字符 b 匹配，匹配成功。因为最小匹配原则，所以拿正则表达式第三个操作符 c 与字符串第三个字符 b 匹配，发现不匹配。于是回溯回去，拿正则表达式第二个操作符 b{1,3}? 和字符串第三个字符 b 匹配，匹配成功。于是再拿正则表达式第三个操作符 c 与字符串第四个字符 c 匹配，匹配成功。于是结束。

## 独占模式

如果在他们之后加多一个 + 符号，那么原先的贪婪模式就会变成独占模式，即尽可能多地匹配，但是不回溯。

# 算法引擎

实现正则表达式引擎的有两种方式：DFA 自动机（Deterministic Final Automata 确定型有穷自动机）和 NFA 自动机（Non deterministic Finite Automaton 不确定型有穷自动机）。

DFA 自动机的时间复杂度是线性的，更加稳定，但是功能有限。而 NFA 的时间复杂度比较不稳定，有时候很好，有时候不怎么好，好不好取决于你写的正则表达式。但是胜在 NFA 的功能更加强大，所以包括 Java 、.NET、Perl、Python、Ruby、PHP 等语言都使用了 NFA 去实现其正则表达式。Java 正则表达式使用的引擎实现是 NFA 自动机，这种正则表达式引擎在进行字符匹配时会发生回溯（backtracking）。而一旦发生回溯，那其消耗的时间就会变得很长，有可能是几分钟，也有可能是几个小时，时间长短取决于回溯的次数和复杂度。

## NFA

那 NFA 自动加到底是怎么进行匹配的呢？我们以下面的字符和表达式来举例说明。

```
text="Today is a nice day."

regex="day"
```

要记住一个很重要的点，即：NFA 是以正则表达式为基准去匹配的。也就是说，NFA 自动机会读取正则表达式的一个一个字符，然后拿去和目标字符串匹配，匹配成功就换正则表达式的下一个字符，否则继续和目标字符串的下一个字符比较。或许你们听不太懂，没事，接下来我们以上面的例子一步步解析。

首先，拿到正则表达式的第一个匹配符：d。于是那去和字符串的字符进行比较，字符串的第一个字符是 T，不匹配，换下一个。第二个是 o，也不匹配，再换下一个。第三个是 d，匹配了，那么就读取正则表达式的第二个字符：a。
读取到正则表达式的第二个匹配符：a。那着继续和字符串的第四个字符 a 比较，又匹配了。那么接着读取正则表达式的第三个字符：y。
读取到正则表达式的第三个匹配符：y。那着继续和字符串的第五个字符 y 比较，又匹配了。尝试读取正则表达式的下一个字符，发现没有了，那么匹配结束。
上面这个匹配过程就是 NFA 自动机的匹配过程，但实际上的匹配过程会比这个复杂非常多，但其原理是不变的。

### NFA 自动机的回溯

了解了 NFA 是如何进行字符串匹配的，接下来我们就可以讲讲这篇文章的重点了：回溯。为了更好地解释回溯，我们同样以下面的例子来讲解。

```
text="abbc"

regex="ab{1,3}c"
```

上面的这个例子的目的比较简单，匹配以 a 开头，以 c 结尾，中间有 1-3 个 b 字符的字符串。NFA 对其解析的过程是这样子的：

- 首先，读取正则表达式第一个匹配符 a 和 字符串第一个字符 a 比较，匹配了。于是读取正则表达式第二个字符。
- 读取正则表达式第二个匹配符 b{1,3} 和字符串的第二个字符 b 比较，匹配了。但因为 b{1,3} 表示 1-3 个 b 字符串，以及 NFA 自动机的贪婪特性（也就是说要尽可能多地匹配），所以此时并不会再去读取下一个正则表达式的匹配符，而是依旧使用 b{1,3} 和字符串的第三个字符 b 比较，发现还是匹配。于是继续使用 b{1,3} 和字符串的第四个字符 c 比较，发现不匹配了。此时就会发生回溯。
- 发生回溯是怎么操作呢？发生回溯后，我们已经读取的字符串第四个字符 c 将被吐出去，指针回到第三个字符串的位置。之后，程序读取正则表达式的下一个操作符 c，读取当前指针的下一个字符 c 进行对比，发现匹配。于是读取下一个操作符，但这里已经结束了。

# 常用正则

```js
('[^\x00-\xff]+'|"[^\x00-\xff]+"|>[^\x00-\xff]+<|^\s*([^\x00-\xff]+)\s*$)
```
