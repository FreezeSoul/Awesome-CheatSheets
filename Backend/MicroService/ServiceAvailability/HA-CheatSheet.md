[![返回目录](https://parg.co/UCb)](https://github.com/wxyyxc1992/Awesome-CheatSheet)

# HA CheatSheet | 一文了解高可用架构关键点：性能指标、负载均衡、缓存、降级与限流

# Load Balancing | 负载均衡

## 负载均衡算法

常用的负载均衡算法有：轮询，随机，最少链接，源地址散列，加权等方式。

| 方式       | 优点                                                                     | 缺点                                         |
| ---------- | ------------------------------------------------------------------------ | -------------------------------------------- |
| 随机       | 简单                                                                     | 不适合机器配置不同的场景                     |
| 轮询       | 每台服务器的请求数目相同                                                 | 服务器压力不一样，不适合服务器配置不同的情况 |
| 最少连接   | 根据服务器当前的请求处理情况，动态分配                                   | 算法实现相对复杂，需要监控服务器请求连接数   |
| 源地址散列 | 将来自同一 IP 地址的请求，同一会话期内，转发到相同的服务器；实现会话粘滞 | 目标服务器宕机后，会话会丢失                 |
| 加权       | 根据权重，调节转发到后端服务器的请求数目                                 | 使用相对复杂                                 |

### 轮询

将所有请求依次分发到每台服务器上，适合服务器硬件配置相同的场景。

### 随机

请求随机分配到各个服务器。

### 最少连接

将请求分配到连接数最少的服务器（目前处理请求最少的服务器）。

### Hash | 源地址散列

根据 IP 地址进行 Hash 计算，得到 IP 地址。

### 加权

在轮询，随机，最少连接，Hash 等算法的基础上，通过加权的方式，进行负载服务器分配。

## 负载均衡分层

- 二层负载均衡会通过一个虚拟 MAC 地址接收请求，然后再分配到真实的 MAC 地址；

- 三层负载均衡会通过一个虚拟 IP 地址接收请求，然后再分配到真实的 IP 地址；

- 四层通过虚拟 IP + 端口接收请求，然后再分配到真实的服务器；

- 七层通过虚拟的 URL 或主机名接收请求，然后再分配到真实的服务器。

我们最为常用的是四层负载均衡与七层负载均衡。四层负载均衡，也就是主要通过报文中的目标地址和端口，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。以常见的 TCP 为例，负载均衡设备在接收到第一个来自客户端的 SYN 请求时，即通过上述方式选择一个最佳的服务器， 并对报文中的目标 IP 地址进行修改(改为后端服务器 IP），直接转发给该服务器。 TCP 的连接建立，即三次握手是客户端和服务器直接建立的，负载均衡设备只是起到一个类似路由器的转发动作。在某些部署情况下，为保证服务器回包可以正确返回给负载均衡设备，在转发报文的同时可能还会对报文原来的源地址进行修改。

所谓七层负载均衡，也称为“内容交换”，也就是主要通过报文中的真正有意义的应用层内容，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。以常见的 TCP 为例，负载均衡设备如果要根据真正的应用层内容再选择服务器，只能先代理最终的服务器和客户端建立连接（TCP 三次握手）后，才可能接收到客户端发送的真正应用层内容的报文， 然后再根据该报文中的特定字段，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。负载均衡设备在这种情况下，更类似于一个代理服务器。负载均衡和前端的客户端以及后端的服务器会分别建立 TCP 连接。所以从这个技术原理上来看，七层负载均衡明显地对负载均衡设备的要求更高，处理七层的能力也必然会低于四层模式的部署方式。

七层应用负载均衡的好处，是使得整个网络更“智能化”, 例如访问一个网站的用户流量，可以通过七层的方式，将对图片类的请求转发到特定的图片服务器并可以使用缓存技术；将对文字类的请求可以转发到特定的文字服务器并可以使用压缩技术。当然这只是七层应用的一个小案例，从技术原理上，这种方式可以对客户端的请求和服务器的响应进行任意意义上的修改，极大的提升了应用系统在网络层的灵活性。 很多在后台(例如 Nginx 或者 Apache )上部署的功能可以前移到负载均衡设备上，例如客户请求中的 Header 重写，服务器响应中的关键字过滤或者内容插入等功能。

另外一个常常被提到功能就是安全性。网络中最常见的 SYN Flood 攻击，即黑客控制众多源客户端，使用虚假 IP 地址对同一目标发送 SYN 攻击，通常这种攻击会大量发送 SYN 报文，耗尽服务器上的相关资源，以达到 Denial of Service(DoS) 的目的。从技术原理上也可以看出，四层模式下这些 SYN 攻击都会被转发到后端的服务器上；而七层模式下这些 SYN 攻击自然在负载均衡设备上就截止，不会影响后台服务器的正常运营。另外负载均衡设备可以在七层层面设定多种策略，过滤特定报文，例如 SQL Injection 等应用层面的特定攻击手段，从应用层面进一步提高系统整体安全。现在的 7 层负载均衡，主要还是着重于应用广泛的 HTTP 协议，所以其应用范围主要是众多的网站或者内部信息平台等基于 B/S 开发的系统。4 层负载均衡则对应其他 TCP 应用，例如基于 C/S 开发的 ERP 等系统。

# Service Degradation | 服务降级

降低一致性
强一致性，将所有的同步一致性，切换为最终一致性，提高吞吐量
弱一致性，必要时候牺牲一致性换取服务整体可靠性
关闭次要服务
不同应用，关闭次要应用，释放物理资源
相同应用，关闭应用次要功能，更多资源给到核心功能
简化服务功能
如简化业务流程，减少通讯数据等

## Throttling | 限流

限流，形象地理解就是在外部系统与内部服务之间添加漏斗状的过滤器，无论输入一侧的流量多少，输出一侧总是以最大可预期的速度进行输出。通常来说，对速率控制可以分为固定速率控制和动态速率控制两种；固定速率控制，根据当前速率决定请求是否被接受，而动态速率控制根据系统压力指标决定请求是否被接受。

固定速率控制常用于预先对系统能力与业务流量估算较好地情况下，可以进行预配置，通常使用 Leaky Bucket 或者 Token Bucket 算法；Nginx 等 Web 服务器，各个语言本身的工具包往往都会支持该系列的算法。

Token Bucket 算法中，有一个独立的模块始终以恒定速率给固定大小的桶补充 token，若桶满了则溢出，即 token 最多为桶的容量；负责处理请求的模块每次接到请求时，首先从桶中获取 token，若能成功获取则继续流程，否则等待响应时间或返回失败。

实际的实现当中，算法可以被优化为系统时间相关的数学运算，也无需单独的线程，仅需要在请求之前插入一小段计算即可实现，因此对性能几乎没有影响。唯一需要考虑的是系统对于获取当前时间的精度支持，这影响速率控制的精度。

限流目的
SLA 保证方式之一
应对突发峰刺流量，一定程度节约容量规划成本
租户隔离策略之一，避免某些用户占用其它用户的资源，导致服务大范围不可用
限流方式
服务降级
服务拒绝
解决方案
服务权重划分，多租户环境将资源按权重划分，保证重要客户的资源
服务延时处理，加入服务缓冲队列延缓服务压力，用于削峰
服务弹性伸缩，依赖服务监控，弹性伸缩容
流控算法
计数器
单机或者集群保存某用户某时间段请求数，达到阈值则触发流控
队列算法
FIFO 队列
请求速度波动，消费速度均匀，队列满则流控
权重队列
按服务划分优先级队列，不同队列权重不同
队列算法设计关键：队列长度的预设非常关键
队列太长，流控未生效，服务已经被打死
队列太短，流控被频繁触发，体验差
漏斗算法
本质上是队列+限流器实现，限流器保证消费速度均匀类 TCP sync backlog
转发速度均匀
令牌桶
中间人已恒定速率向桶里发放令牌，服务请求拿到 token 则开始服务，否则不处理
转发速度不均匀，流量小时积累，流量大时消费
动态流控
实时计算服务能力如 QPS，对比服务 RT 如果 RT 过大，则减少 QPS
设计要点
手动开关，主动运维和应急使用
监控通知，限流发生时干系人要清楚
用户感知，如返回特定错误信息（错误 code/错误提示）
链路标识，RPC 链路加入限流标识方便上下游业务识别限流场景做不同处理

## 熔断

场景
过载保护，系统负载过高情况为防止故障产生，而采取的一种保护措施
防止应用程序不断尝试可能会失败的操作
三个状态
Closed，闭合状态，正常状态，系统需要一个基于时间线到错误计数器，如果错误累计达到阈值则切换至 Open 状态
Open，断开状态，所有对服务对请求立即返回错误，不用调用后端服务进行计算
Half-Open，半开状态，允许部分请求流量进入并处理，如果请求成功则按照某种策略切换到 Closed 状态
设计要点
定义触发熔断的错误类型
所有触发熔断的错误请求必须要有统一的日志输出
熔断机制必须有服务诊断及自动恢复能力
最好为熔断机制设置手动开关用于三种状态的切换
熔断要切分业务，做到业务隔离熔断
